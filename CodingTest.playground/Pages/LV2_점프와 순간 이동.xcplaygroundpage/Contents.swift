import Foundation

/*
- 아이언 슈트가 존재
- 슈트는 점프 및 순간이동 작동(점프는 점프 수 만큼 배터리 소모, 순간이동은 현재까지 온거리 * 2 만큼 해당위치로 무료 이동)
- N의 거리가 주어질 때 점프이동을 최소화하고 순간이동이 효율적
- N의 위치가 주어질 때 건전지 사용량이 제일 적은값(최솟값)을 return하는 함수 구현
*/
// n만큼의 거리가 주어젔을 때 지워나가면서 역으로 추적해나가는 방식
func solution(_ n:Int) -> Int {
    // n 이동해야할 거리 할당
    var n = n
    // 배터리 사용량 할당
    var batteryCnt = 0

    // 이동해야할 거리를 점차 줄여나가기를 목적으로 반복문 진행(0이 될때까지)
    while n > 0 {
        // 짝수이면 순간이동으로도 도착이 가능(배터리 소모 없이 가능)
        if n % 2 == 0 {
            n /= 2
        } else {
            /*
             홀수일경우 점프를해서 왔다는 이유로 n에 -1을 하고
             점프를 해서 왔기에 배터리사용값 +1을 추가
             */
            n -= 1
            batteryCnt += 1
        }
    }
    return batteryCnt
}

//solution(6)
// 생각보다 어려웠다. 아이패드에 수기로 작성해가면서 3시간은 사용한것같은데, 이동거리를 점점 올릴것이 아니라 하나씩 덜어내간다는 방식을 왜 생각을 못했을까.. 반성하게 된다.
